#feature WITH_EDGE
#feature CUSTOM_PROJECT
#feature CUSTOM_VIEWPORT
#feature FIXED_SCALE

#shader vertex
#version 450 core

#include ":Shaders/Common/Buffers/EngineUBO.ovfxh"

layout(location=0) in vec4 aPositionSize;
layout(location=1) in vec4 aColor;
layout(location=2) in vec3 aNormal;
layout(location=3) in vec2 aUv; 

uniform mat4 uModelMatrix;
#if defined(CUSTOM_PROJECT)
uniform mat4 uViewMatrix;
uniform mat4 uVProjMatrix;
#endif

out VSOutPut{
    vec3 pos;
    vec3 normal;
    vec4 color;
    vec2 uv;
}vData;

void main() 
{
    vData.color = aColor.rgba; // swizzle to correct endianness
    vData.pos= aPositionSize.xyz;
    //the follow doesn't use CUSTOM_PROJECT
    #if defined(FIXED_SCALE)
        //orth
        if(ubo_CameraType==0){
          float ratio=400.0/(ubo_Projection[1][1]*ubo_ScreenHeight);
          vData.pos=vData.pos*ratio;
        }
        else{
          vec4 viewPos= ubo_View * uModelMatrix*vec4(vData.pos,1.0f);
          viewPos.z/=viewPos.w;
          float h=viewPos.z*1/ubo_Projection[1][1];
          float ratio=400.0*abs(h)/ubo_ScreenHeight;
          vData.pos=vData.pos*ratio;
        }
    #endif
    vData.normal=normalize(mat3(uModelMatrix)*aNormal);

    vData.uv=aUv;
#if defined(CUSTOM_PROJECT)
    gl_Position = uVProjMatrix*uViewMatrix * uModelMatrix*vec4(vData.pos, 1.0);
#else
    gl_Position = ubo_Projection * ubo_View * uModelMatrix*vec4(vData.pos, 1.0);
#endif
   
 

}
#shader geomerty

#version 450 core
#if defined(WITH_EDGE)
#include ":Shaders/Common/Buffers/EngineUBO.ovfxh"

in VSOutPut{
    vec3 pos;
    vec3 normal;
    vec4 color;
    vec2 uv;
}gs_in[];

out GS_OUT{
    vec3 pos;
    vec3 normal;
    vec4 color;
    vec2 uv;
    noperspective vec4 edgeEqn[3];
} gs_out;


layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

#if defined(CUSTOM_VIEWPORT)
uniform float uViewPortSize;
#endif

uniform usamplerBuffer edgeTexture;

void main() 
{
    vec2 pos[4];
    
    #if defined(CUSTOM_VIEWPORT)
    vec2 viewS=vec2(ubo_ScreenWidth-uViewPortSize,ubo_ScreenHeight-uViewPortSize);
    #endif
    
    for (int i = 0; i < 3; i++)
    {
        pos[i] = gl_in[i].gl_Position.xy/gl_in[i].gl_Position.w;
        pos[i] = pos[i]*vec2(0.5) + vec2(0.5);
        #if defined(CUSTOM_VIEWPORT)
            pos[i] = pos[i]*vec2(uViewPortSize,uViewPortSize)+viewS;
        #else
            pos[i] = pos[i]*vec2(ubo_ScreenWidth,ubo_ScreenHeight);     
        #endif
    }
    pos[3] = pos[0];  

    float ccw = sign(cross(vec3(pos[1] - pos[0], 0.0), vec3(pos[2] - pos[0], 0.0)).z);

    for (int i = 0; i < 3; i++)
    {
        vec2 tmp = normalize(pos[i+1] - pos[i]);
        tmp = ccw*vec2(-tmp.y, tmp.x);
        float d = dot(pos[i], tmp);
        gs_out.edgeEqn[i] = vec4(tmp.x, tmp.y, 0.0, -d);
    }
    
    uint edgeValues = texelFetch(edgeTexture, gl_PrimitiveIDIn).r;
    if (float(edgeValues) < 4.0) gs_out.edgeEqn[0].z = 1.5;
    if (mod(float(edgeValues), 4.0) < 2.0) gs_out.edgeEqn[1].z = 1.5;
    if (mod(float(edgeValues), 2.0) < 1.0) gs_out.edgeEqn[2].z = 1.5;


    for (int i = 0; i < 3; i++)
    {
        gl_PrimitiveID = gl_PrimitiveIDIn;
        gs_out.pos=gs_in[i].pos;
        gs_out.normal=gs_in[i].normal;
        gs_out.color=gs_in[i].color;
        gs_out.uv=gs_in[i].uv;
        gl_Position = gl_in[i].gl_Position;
        EmitVertex();
    }
    EndPrimitive();
}
#endif

#shader fragment
#version 450 core
#include ":Shaders/Lighting/PBR.ovfxh"
#if defined(WITH_EDGE)
in GS_OUT{
    vec3 pos;
    vec3 normal;
    vec4 color;
    vec2 uv;
    noperspective vec4 edgeEqn[3];
} fs_in;
#else
in VSOutPut{
    vec3 pos;
    vec3 normal;
    vec4 color;
    vec2 uv;
}fs_in;
#endif

layout(location=0) out vec4 fResult;
uniform mat4 uViewMatrix;
uniform sampler2D u_AlbedoMap;
void main() 
{
    vec4 albedo = texture(u_AlbedoMap, fs_in.uv)*fs_in.color;
#if defined(WITH_EDGE)
    float edist[3];
    edist[0] = dot(fs_in.edgeEqn[0].xy, gl_FragCoord.xy) + fs_in.edgeEqn[0].w;
    edist[1] = dot(fs_in.edgeEqn[1].xy, gl_FragCoord.xy) + fs_in.edgeEqn[1].w;
    edist[2] = dot(fs_in.edgeEqn[2].xy, gl_FragCoord.xy) + fs_in.edgeEqn[2].w;
    if (edist[0] < -0.5 && fs_in.edgeEqn[0].z > 0.0) discard;
    if (edist[1] < -0.5 && fs_in.edgeEqn[1].z > 0.0) discard;
    if (edist[2] < -0.5 && fs_in.edgeEqn[2].z > 0.0) discard;
    edist[0] += fs_in.edgeEqn[0].z;
    edist[1] += fs_in.edgeEqn[1].z;
    edist[2] += fs_in.edgeEqn[2].z;
    float emix = clamp(0.5 + 0.5*1.5 - min( min( edist[0], edist[1]), edist[2]), 0.0, 1.0);
    albedo.rgb = mix(albedo.rgb, vec3(0.3,0.3,1.0), emix);
#endif

    vec3 viewDir=vec3(uViewMatrix[0][2],uViewMatrix[1][2],uViewMatrix[2][2]);
    vec3 lightDir=viewDir;
    vec3 N=fs_in.normal;
    if(dot(N,viewDir)<0){
        N=-N;
    }

    float diff=max(dot(lightDir,N),0);
    vec3 diffuse=diff*albedo.rgb;
    vec3 specular=sign(diffuse)*pow(max(dot(N,lightDir),0),100)*0.03*albedo.rgb;
    vec3 col=diffuse+specular;
    col=pow(col, vec3(2.2));
    fResult = vec4(col,1.0);	
}
